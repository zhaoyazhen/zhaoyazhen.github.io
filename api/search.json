[{"id":"05578dbc946a53c7742b35135ebdeca1","title":"CSS中filter属性的使用详解","content":"前一段时间，小编突然接到了一个紧急需求，将公司的线上小程序置为灰色主题，然而项目中没有定义基础颜色变量，且小程序页面有五六十个，额。。。，头疼的不是一点点，后面发现了 filter 这个属性，一下子解了我的燃眉之急，遂对于这个神奇的属性进行了一波详细的学习。\n一、filter 属性简介filter 用于给元素（通常是图片、背景、文字甚至整个容器）应用图像处理效果，如模糊、灰度、对比度等。语法如下：\n123.selector &#123;  filter: none | &lt;filter-function&gt; [&lt;filter-function&gt; ...];&#125;\n\n\nnone：无滤镜效果（默认值）。\n&lt;filter-function&gt;：一个或多个滤镜函数，可以叠加。\n\n二、常用滤镜函数1、blur() 模糊\n12// 值越大，模糊程度越高(常用于背景虚化（毛玻璃效果需配合 backdrop-filter）)filter: blur(5px);\n\n2、brightness() 亮度\n12// 100% → 原始亮度；&gt;100% → 变亮；&lt;100% → 变暗；0 → 全黑；filter: brightness(150%);\n3、contrast() 对比度\n12// 100% → 原始对比度；&gt;100% → 提高对比度；&lt;100% → 降低对比度，趋向灰色filter: contrast(200%);\n\n4、grayscale() 灰度\n12// 常用于图片灰化/禁用状态（100% → 全灰度（黑白效果）；0% → 原始颜色；）filter: grayscale(100%);\n\n5、invert() 反色\n12// 常用于暗色模式适配 (100% → 完全反色；50% → 半反色（类似负片效果）；)filter: invert(100%);\n\n6、opacity() 透明度\n12// 与 opacity 属性不同，filter: opacity() 不会影响子元素事件（1 或 100% → 完全不透明；0 → 完全透明；）filter: opacity(50%);\n\n7、saturate() 饱和度\n12// 100% → 原始饱和度；&gt;100% → 增强饱和度；0% → 去色（灰色）；filter: saturate(200%);\n\n8、sepia() 怀旧色（褐色调）\n12// 常用于复古照片效果（100% → 完全褐色效果；）filter: sepia(100%);\n\n9、hue-rotate() 色相旋转\n12// 通过旋转色轮改变颜色，用于动态色彩切换（0deg → 原始颜色；）filter: hue-rotate(90deg);\n\n10、drop-shadow() 阴影\n12// 与 box-shadow 类似，但可应用于透明 PNG / SVGfilter: drop-shadow(5px 5px 10px rgba(0,0,0,0.5)); // 语法：drop-shadow(offset-x offset-y blur-radius color)\n\n11、多个滤镜叠加\n12// 执行顺序从左到右，先灰度 → 再模糊 → 再调亮filter: grayscale(100%) blur(2px) brightness(120%);\n\n三、backdrop-filter（背景滤镜）  不同于 filter 作用于元素自身，backdrop-filter 用于 处理元素背后的内容。eg: 毛玻璃效果\n  1234567// 需要父元素有半透明背景才有效，且部分浏览器需加 -webkit- 前缀.glass &#123;  /* 半透明背景 + 背景模糊 */  background: rgba(255, 255, 255, 0.3);  backdrop-filter: blur(12px) brightness(110%);  -webkit-backdrop-filter: blur(12px) brightness(110%);&#125;\n\ntips1：滤镜会触发 GPU 加速，但在大面积模糊或动画时性能消耗大，谨慎使用。\ntips2：backdrop-filter 支持度不如 filter，需检查兼容性。\nfilter：主流浏览器（Chrome、Firefox、Safari、Edge）都支持。\nbackdrop-filter：Safari 先支持，Chrome&#x2F;Edge 需新版本，Firefox 需手动开启实验功能。\n\n\n\n四、使用场景1、小程序设置灰色页面\n123page &#123;  filter: grayscale(1);&#125;\n\n存在问题：给page标签使用灰色滤镜后导致’position: fixed’位置错乱，无法正确定位，样式错乱。\n问题原因：当 filter 不为 none 的时候，如果该元素或者其子元素具有 absolute 或 fixed 属性，那么它会为其创建一个新的包含块&#x2F;容器，会造成该 absolute 或 fixed 元素的定位发生变化（就是改变了 absolute 或 fixed 元素的定位 父 元素，变成新创建的元素）。\n解决方案：不对page view标签设置滤镜filter，只对 text button image video等具体标签设置滤镜，eg: \n123button, text, span, video, image &#123;  filter: grayscale(1);&#125;\ntips: 最好逐个元素排查，确保设置了 filter 的元素，不包含存在 fixed 定位的子元素。\n2、普通网站设置灰色页面\n123html &#123;  filter: grayscale(100%);&#125;\n\ntips1: 将filter 设置在根元素上，它是不会为 absolute 或 fixed 子元素创建新的包含块的，因此我们可以通过将filter设置在根元素（html）上来避免定位问题。若在 body 标签中使用了 filter 属性后（body { filter: grayscale(100%); ）， filter 就会生成一个新的包含块，其位置大小和 body 一样，然后 fixed 元素就会根据这个包含块进行定位，导致定位出现问题，原因同上。\ntips2: 配置了 css filter 属性的元素，z-index 会被提升，处于同一层级时可能会覆盖掉其他有定位元素，需要注意调整 z-index 层级。\n3、拓展内容：实现追悼日网站自动变成灰色\n1234567891011121314151617181920212223242526272829303132333435// 在项目入口文件App.vue中进行以下设置&lt;script&gt;export default &#123;  created() &#123;    this.getMournDate()  &#125;,  methods: &#123;    getMournDate() &#123;      // 调用接口获取后台设置的追悼日期范围（起始日~截止日）      this.mournDate =  &#123;        start: 1669824000000, // 2022-12-01        end: 1670601600000 // 2022-12-10      &#125;      this.checkMourn(this.mournDate)    &#125;,    checkMourn(mournDate) &#123;      const now = new Data().getTime()      if (mournDate.start &lt;= now &amp;&amp; now &lt;= mournDate.end) &#123;        // 追悼日只有设置在html元素上才不会影响fixed和absolute定位        document.documentElement.style.filter = &#x27;grayscale(100%)&#x27;        setTimeout(() =&gt; &#123; // 自动取消黑白          document.documentElement.style.filter = &#x27;none&#x27;        &#125;, mournDate.end - now)      &#125; else &#123;        document.documentElement.style.filter = &#x27;none&#x27;        if (now &lt; mournDate.start) &#123; // 自动变为黑白          setTimeout(() =&gt; &#123;            document.documentElement.style.filter = &#x27;grayscale(100%)&#x27;          &#125;, mournDate.start - now)        &#125;      &#125;    &#125;  &#125;&#125;&lt;/script&gt;\n\n4、其他网友问题（小编未遇到该问题）\n  问题1: filter导致css无效\n  问题定位：首先要确定是由filter引起的css无效，浏览器中按F12打开开发者工具，然后如果在console中出现这样一行警告：‘Resource interpreted as Stylesheet but transferred with MIME type text&#x2F;html: ’，那大概就是因为filter的问题导致的。\n  解决方案：把filter中涉及response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);的地方替换成这样：\n  12345678910111213141516 // 前面需要 import javax.servlet.http.HttpServletRequest;public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;   // TODO Auto-generated method stub // place your code here   HttpServletRequest req = (HttpServletRequest) request;   String requestURI = req.getRequestURI();   if (requestURI.contains(&quot;.css&quot;) || requestURI.contains(&quot;.js&quot;)) &#123;     request.setCharacterEncoding(&quot;UTF-8&quot;);     response.setCharacterEncoding(&quot;charset=UTF-8&quot;);     chain.doFilter(request, response);   &#125; else &#123;     request.setCharacterEncoding(&quot;UTF-8&quot;);     response.setContentType(&quot;text/html;charset=UTF-8&quot;);//这样会把CSS文件和JS文件转化为html文件,但是在if中排除了     chain.doFilter(request, response);   &#125; &#125;\n\n参考链接：「丸子家的银河龙」\n","slug":"CSS-filter","date":"2025-08-21T10:38:40.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"YaZhen"},{"id":"785e956e66b583943c71b60dbc7dba1a","title":"CSS实现三角形的多种方式","content":"日常开发中，我们经常会遇到需要前端手动绘制三角形的场景（比如：后台管理系统开发没有设计稿或者需求紧急等等，懂得都懂），故小编对以往的实现方式进行了总结，以便后续方便使用。\n一、边框（border）法 &#x2F; transform 旋转  实现原理：一个元素宽高都为 0，利用 透明边框 和 有色边框 叠加出三角形，如下图：\n  \n\n  实现代码：  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 箭头向上的三角形.triangle-up &#123;  width: 0;  height: 0;  border-left: 50px solid transparent;  border-right: 50px solid transparent;  border-bottom: 100px solid red;&#125;// 箭头向右的三角形.triangle-right &#123;  width: 0;  height: 0;  border-top: 50px solid transparent;  border-left: 100px solid red;  border-bottom: 50px solid transparent;&#125;// 箭头向上左的三角形.triangle-topleft &#123;  width: 0;  height: 0;  border-top: 100px solid red;  border-right: 100px solid transparent;&#125;// 带阴影效果的三角形（给 border-top 和 border-right 同时设置颜色，然后通过 transform 进行旋转操作，将盒模型原本的两条边作为三角形的腰，对外展示，再对其设置box-shadow效果，实现阴影效果。）.triangle-shadow &#123;   position: relative;  width: 100px;  height: 100px;  background: #fff;  border: 1px solid #ccc;  box-shadow: 0 0 4px #ccc;  &amp;:after &#123;    position: absolute;    display: inline-block;    top: 86px;    left: 40px;    width: 0;    height: 0;    content: &#x27;&#x27;;    border-style: solid;    border-width: 12px;    border-color: #fff #fff transparent transparent; // 会形成4个不同颜色的三角形，两个白色的三角形形成一个大的三角形（若三角形颜色与父组件颜色一致，设置一个颜色也可实现三角形）    transform: rotate(135deg);    box-shadow: 2px -2px 2px #ccc;  &#125;&#125;\n  优点：简单、性能好（border 边框法支持全浏览器，transform 支持IE9+等）  缺点：形状有限（等腰直角&#x2F;等腰等边）\n二、clip-path（裁剪路径）  实现代码：  123456.triangle-clip &#123;  width: 100px;  height: 100px;  background: #3498db;  clip-path: polygon(50% 0, 0 100%, 100% 100%);&#125;\n  优点：灵活，可以画任意多边形  缺点：老旧浏览器兼容性差（IE 不支持）\n三、渐变（linear-gradient &#x2F; conic-gradient）  实现代码：  12345678910111213// 渐变的透明和不透明部分形成三角（支持 IE9+ 等）.triangle-linear &#123;  width: 100px;  height: 100px;  background: linear-gradient(135deg, #2ecc71 50%, transparent 50%);&#125;// 锥形渐变（支持 Chrome 69+，Safari 12.1+，Firefox 83+ 等）.triangle-conic &#123;  width: 100px;  height: 100px;  background: conic-gradient(#9b59b6 0 120deg, transparent 120deg);&#125;\n四、mask-image  实现代码：  123456789101112131415// 不支持IE，支持 Safari / Chrome 等.triangle-mask &#123;  width: 100px;  height: 100px;  background: #f39c12;  /* 遮罩必须用 image/gradient，不支持 polygon() */  -webkit-mask-image: linear-gradient(to bottom right, black 50%, transparent 50%);  -webkit-mask-repeat: no-repeat;  -webkit-mask-size: 100% 100%;  mask-image: linear-gradient(to bottom right, black 50%, transparent 50%);  mask-repeat: no-repeat;  mask-size: 100% 100%;&#125;\n五、字符符号  实现代码：  123456// 支持全浏览器.triangle-char::before &#123;  content: &quot;▲&quot;;  font-size: 60px;  color: #e67e22;&#125;\n六、shape-outside (文字环绕)  实现代码：  123456789101112131415// 不支持 IE ，支持 Chrome / Safari.float-triangle &#123;  float: left;  width: 150px;  height: 150px;  shape-outside: polygon(50% 0, 0 100%, 100% 100%);  clip-path: polygon(50% 0, 0 100%, 100% 100%);  background: #34495e;  margin: 0 15px 10px 0;&#125;.demo-shape p &#123;  font-size: 14px;  line-height: 1.6;&#125;\n七、SVG + background  严格说不算“纯 CSS”，但可以写在 CSS background-image: url(“data:image&#x2F;svg+xml;…”)，实现三角。\n八、Houdini Paint API (需浏览器支持)  Houdini Paint API 对于部分同学来说比较陌生，它是 CSS Houdini 家族中最常用的一部分，允许你通过 JavaScript 自定义 CSS 背景绘制，就像给 CSS 增加一个“会编程的 background-image”。本质是通过 JS 注册一个“绘制器（Painter）”，浏览器在绘制时调用它，用 Canvas API 绘制图像。使用示例如下：\n  123456789101112131415161718192021222324252627282930&lt;style&gt;  .triangle-houdini &#123;    width: 100px;    height: 100px;    background: paint(triangle);  &#125;&lt;/style&gt;&lt;script&gt;  /* 注册 Houdini Paint Worklet */  if (&#x27;paintWorklet&#x27; in CSS) &#123;    const code = `      class TrianglePainter &#123;        paint(ctx, size) &#123;          ctx.fillStyle = &#x27;#16a085&#x27;;          ctx.beginPath();          ctx.moveTo(size.width / 2, 0);          ctx.lineTo(0, size.height);          ctx.lineTo(size.width, size.height);          ctx.closePath();          ctx.fill();        &#125;      &#125;      registerPaint(&#x27;triangle&#x27;, TrianglePainter);    `;    const blob = new Blob([code], &#123; type: &#x27;application/javascript&#x27; &#125;);    const url = URL.createObjectURL(blob);    CSS.paintWorklet.addModule(url);  &#125;&lt;/script&gt;\n\n  tips: 目前 Chrome、Edge、Opera 支持好（实验性 API，需要 HTTPS）；Firefox、Safari 支持不完整，需要 flag；移动端支持有限。\n","slug":"CSS-triangle","date":"2025-08-20T12:47:22.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"YaZhen"},{"id":"28b56a6d628adf0e2a41ab59435138a8","title":"使用hexo搭建个人博客","content":"Hexo 是一个快速、简洁且高效的静态博客框架，支持丰富的主题和插件，非常适合前端进行个人博客的搭建，以下是小编使用 Hexo 搭建个人博客的步骤记录：\n一、安装 Node.js 和 NPM  Hexo 依赖于 Node.js 环境，因此需要先安装 Node.js 和 NPM（Node.js 官网），安装完成后，打开终端（Terminal），运行以下命令来验证安装：\n  12node -v   npm -v\n\ntips: 建议安装 14.0.0 以上的node版本，具体 hexo 版本 与 node 版本关系可参考 hexo 官网\n二、安装 Hexo  接下来，全局安装 Hexo：\n  1npm install -g hexo-cli\n\n三、初始化 Hexo 博客  选择一个文件夹来存放你的博客文件，然后在该文件夹下运行以下命令初始化一个 Hexo 项目：\n  123hexo init my-blogcd my-blognpm install\n四、启动 Hexo 本地开发服务器  初始化完成后，你可以在本地预览你的博客：\n  1hexo server\n  然后打开浏览器，访问 http://localhost:4000， 你应该可以看到 Hexo 默认的欢迎页面。\n五、配置 Hexo 博客  Hexo 博客的配置文件位于 &#x2F;_config.yml。你可以根据需要进行修改，如设置博客名称、描述、作者信息等。具体配置项请参考 Hexo 配置文档。\ntips: 每次修改配置文件后，建议执行 hexo clean &amp; hexo g &amp; hexo server 命令重新生成静态文件并启动服务器\n六、安装主题  Hexo 支持各种主题，默认自带为 landscape 主题。如果想安装其他主题，可以从 Hexo 官方主题库上找到你喜欢的主题并按照说明进行安装。小编安装的是 Aurora 主题（具体可查看 Aurora 主题库文档）：\ntips: 1、Aurora 生成主题配置时，非 Linux 系统用户需新建 _config.aurora.yml 文件，并点击‘模版’跳转后复制配置内容tips: 2、文章数量少于3个时，首页推荐位和下面的文章列表存在问题；数量不少于3个时正常\n七、创建文章 &amp; 生成静态文件123hexo new &quot;我的新文章&quot; // 创建一个新文章hexo new page --path about/me &quot;About me&quot; // 创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot;hexo generate // 在 public 目录下生成所有的静态文件，可以直接部署到服务器或平台上\n\ntips: 更多 hexo 命令请查看 Hexo 官方文档\n八、部署到 GitHub Pages（可选）  Hexo 可以很方便地部署到 GitHub Pages。\n\n1、在 gitHub 上创建一个名为 username.github.io的储存仓库，具体可查看 GitHub Pages 文档。\n\n2、安装 Hexo 的部署插件：\n\n\n  1npm install hexo-deployer-git --save\n\n\n3、配置部署信息，打开 &#x2F;_config.yml，找到 deploy 部分并修改：\n\n  1234deploy:  type: git  repo: https://github.com/your-username/your-repo.git // 调整为自己的gitHub仓库地址 (配置时删除注释)  branch: master // 调整为自己的默认分支，通常为 master 或 main (配置时删除注释)\n\n\n4、然后运行以下命令进行部署：\n\n  1hexo deploy\n\n九、配置自定义域名（可选）  我们可以在 GitHub Pages 上配置自定义域名，具体可查看 GitHub Pages 文档，简易步骤如下图所示：\n  \n\n\n  tips: 小编设置 Custom domain 时，出现了错误提示：The custom domain xxxxxx is already taken. If you are the owner of this domain…，解决方案如下图：\n  ","slug":"hexo-blog","date":"2025-08-16T08:24:53.000Z","categories_index":"hexo","tags_index":"博客搭建","author_index":"YaZhen"}]